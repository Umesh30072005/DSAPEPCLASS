Magical Sqare : 

public static long countPerfectSquaresInRange(long L, long R) {

    long start = (long) Math.ceil(Math.sqrt(L));
    long end = (long) Math.floor(Math.sqrt(R));
    if (start > end) {
        return 0;
    }
    return end - start + 1;
}

---------------------------------------------------------------------

Counting Uniq Artifacts : 

public static int countDistinctArtifacts(int[] ids) {
    // add your code here
    HashMap<Integer,Integer>map = new HashMap<>();
    int count  =0;
    for(int i = 0;i<ids.length;i++){
    
    int uniq =  ids[i];
    if (!map.containsKey(uniq)){
        map.put(ids[i],1);
        count++;
    }
    }
    return count;
}

---------------------------------------------------------------------
Check if array is sorted :

public static String isArraySorted(int[] arr) {

    for (int i = 0; i < arr.length - 1; i++) {
        if (arr[i] > arr[i + 1]) {
            return "NO";  
        }
    }
    return "YES";         
}
----------------------------------------------------------------------
The Lost Grimirine : 

public static int findGrimoire(int[] ids, int target) {
    // add your code here
    int left = 0;
    int right = ids.length-1;
    if(ids.length <= 0){
        return 0;
    }
    while(left<=right){
        int mid = left + (right - left)/2;
        if(ids[mid] == target ){
            return 1;
        }
        else if(ids[mid] < target){
            left = mid +1;
        }
        else if(ids[mid]>target){
            right = mid -1;
        }
    }
    return 0;
}
-----------------------------------------------------------------------
Height Mismacth Count: 

public static int solve(int[] nums) { 
    int[] expected = Arrays.copyOf(nums, nums.length);
    Arrays.sort(expected);
    int count = 0;
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] != expected[i]) {
            count++;
        }
    }
    return count;
}

-----------------------------------------------------------------------
Librearians inventory count :

public static int countOccurrences(int[] arr, int target) {

    int first = firstIndex(arr, target);
    if (first == -1) return 0;

    int last = lastIndex(arr, target);
    return last - first + 1;
}

// Find first occurrence
private static int firstIndex(int[] arr, int target) {
    int left = 0, right = arr.length - 1;
    int ans = -1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (arr[mid] == target) {
            ans = mid;
            right = mid - 1;   // move left
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return ans;
}

// Find last occurrence
private static int lastIndex(int[] arr, int target) {
    int left = 0, right = arr.length - 1;
    int ans = -1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (arr[mid] == target) {
            ans = mid;
            left = mid + 1;    // move right
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return ans;
}
-----------------------------------------------------------------
Balanced Treasure Point :

public static int balancedTreasurePoint(int[] arr) {
    // add your code here
    int totalsum = 0;
    int leftsum = 0;
    for(int num : arr){
        totalsum += num;
    }
    for(int i = 0;i<arr.length;i++){
        int rightsum = totalsum - leftsum -arr[i];
        if(rightsum == leftsum){
            return i;
        }
        leftsum += arr[i];
    }
    return -1;
}
---------------------------------------------------------------------
GemStone necklace pivote : 

using binaray:
public static int findSmallest(int[] gems) {
    int left = 0;
    int right = gems.length - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (gems[mid] > gems[right]) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return gems[left];
}
-------------------------(OR)-------------------------------------------
public static int findSmallest(int[] gems) {

    int min = gems[0];   // assume first element is smallest

    for (int i = 1; i < gems.length; i++) {
        if (gems[i] < min) {
            min = gems[i];
        }
    }
    return min;
}
-------------------------------------------------------------------------
Half Palendrome : 

public static String isHalfPalindrome(String s) {
    // add your code here
    int n = s.length();
    String sub;
    if(n%2 == 0){
        sub = s.substring(0,n/2);
    }else{
        sub = s.substring(0,n/2+1);
    }
    int l = 0;
    int r = sub.length()-1;
    while(l<r){
        if(sub.charAt(l) != sub.charAt(r)){
            return "NO";
        }
        l++;
        r--;
    }
    return "YES";
    }
-----------------------------------------------------------------------------
